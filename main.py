#!/usr/bin/env python3
# main.py — generate a hollow hemispherical star dome (.scad)
from skyfield.api import load, wgs84, Star
from skyfield.data import hipparcos
import numpy as np
import shutil, subprocess

# ----------------- USER SETTINGS -----------------

# El Cotillo, Fuerteventura, Canary Islands latitude and longitude
latitude = 28.4016        # degrees
longitude = -14.0035        # degrees
radius = 100.0         # mm, outer radius of dome
thickness = 3.0        # mm, wall thickness
magnitude_limit = 5.0  # include stars brighter than this (larger => more stars)
scad_out = "star_dome.scad"
stl_out = "star_dome.stl"
auto_export = False    # set True to call openscad automatically (requires openscad in PATH)
# -------------------------------------------------

ts = load.timescale()
t = ts.utc(2024, 11, 10)
planets = load('de421.bsp')
earth = planets['earth']
observer = earth + wgs84.latlon(latitude, longitude)

# load Hipparcos catalog (cached by skyfield)
with load.open(hipparcos.URL) as f:
    df = hipparcos.load_dataframe(f)

# convert to Skyfield Star objects and compute alt/az
stars = Star.from_dataframe(df)
astrometric = observer.at(t).observe(stars)
apparent = astrometric.apparent()
alt, az, _ = apparent.altaz()

# keep only stars above horizon and within magnitude limit
mask = alt.degrees > 0
alt = alt.radians[mask]; az = az.radians[mask]
mags_all = df['magnitude'].values[mask] # star apparent magnitude, the smaller the brigher
mag_mask = mags_all < magnitude_limit
alt = alt[mag_mask]; az = az[mag_mask]; mags = mags_all[mag_mask]

# spherical-to-cartesian on unit sphere, then scale to mm radius
x = np.cos(alt) * np.cos(az)
y = np.cos(alt) * np.sin(az)
z = np.sin(alt)
X = x * radius
Y = y * radius
Z = z * radius

# hole radius mapping (mm) — tweak formula to taste
hole_r = np.clip(2.0 - 0.3 * mags, 0.35, 3.0)

# make cylinders long enough to cut through the shell completely
hole_length = radius * 2 + 10.0

# --- build OpenSCAD code ---
lines = []
lines.append("// star_dome.scad generated by main.py")
lines.append(f"R = {radius};")
lines.append(f"thickness = {thickness};")
lines.append(f"hole_length = {hole_length};")
lines.append("")
lines.append("// Build a hollow hemisphere by intersecting a shell with z>=0")
lines.append("difference() {")
lines.append("  intersection() {")
lines.append("    difference() {")
lines.append("      sphere(r=R);")
lines.append("      sphere(r=R - thickness);")
lines.append("    }")
lines.append("    // keep only the upper half (z >= 0)")
lines.append("    translate([-R, -R, 0]) cube([2*R, 2*R, R]);")
lines.append("  }")
lines.append("")
lines.append("  // subtract star holes (format: [x,y,z,hole_radius])")
lines.append("  for (s = [")

for xi, yi, zi, hr in zip(X, Y, Z, hole_r):
    lines.append(f"    [{xi:.4f}, {yi:.4f}, {zi:.4f}, {hr:.4f}],")

lines.append("  ]) {")
lines.append("    v = [s[0], s[1], s[2]];")
lines.append("    norm = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);")
lines.append("    // OpenSCAD trig uses degrees; acos returns degrees")
lines.append("    angle = acos(v[2] / norm);")
lines.append("    axis = (abs(v[0]) < 1e-6 && abs(v[1]) < 1e-6) ? [1,0,0] : [-v[1], v[0], 0];")
lines.append("    translate(v)")
lines.append("      rotate(a=angle, v=axis)")
lines.append("        cylinder(h=hole_length, r=s[3], center=true);")
lines.append("  }")
lines.append("}")

scad_code = "\n".join(lines)

with open(scad_out, "w") as f:
    f.write(scad_code)


num_stars = len(mags)
print(f"Wrote {scad_out} — hollow hemisphere with {num_stars} star holes (mag < {magnitude_limit}).")
if auto_export:
    if shutil.which("openscad"):
        subprocess.run(["openscad", "-o", stl_out, scad_out], check=True)
        print(f"Wrote {stl_out} — ready for 3D printing.")
    else:
        print("openscad not found in PATH. Install OpenSCAD or set auto_export=False.")
